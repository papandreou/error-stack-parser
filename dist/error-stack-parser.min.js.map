{"version":3,"sources":["stackframe.js","error-stack-parser.js"],"names":["root","factory","define","amd","exports","module","StackFrame","this","_isNumber","n","isNaN","parseFloat","isFinite","_capitalize","str","toUpperCase","substring","_getter","p","obj","Object","props","booleanProps","concat","numericProps","stringProps","arrayProps","i","length","hasOwnProperty","undefined","prototype","getArgs","args","setArgs","v","toString","call","TypeError","getEvalOrigin","evalOrigin","setEvalOrigin","functionName","getFunctionName","join","fileName","getFileName","lineNumber","getLineNumber","columnNumber","getColumnNumber","Boolean","j","Number","k","String","require","ErrorStackParser","_map","array","fn","thisArg","Array","map","output","_filter","filter","push","_indexOf","target","indexOf","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","parse","error","stacktrace","parseOpera","stack","match","parseV8OrIE","parseFFOrSafari","Error","extractLocation","urlLike","regExp","parts","exec","replace","filtered","split","line","tokens","slice","locationParts","pop","source","e","message","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","result","len","argsRaw","functionCall","shift"],"mappings":"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","file":"error-stack-parser.min.js","sourcesContent":["(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str[0].toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function () {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            var props = booleanProps.concat(numericProps.concat(stringProps.concat(arrayProps)));\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function () {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function (v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function () {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function (p) {\n            return function (v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function (p) {\n            return function (v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function (p) {\n            return function (v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    function _map(array, fn, thisArg) {\n        if (typeof Array.prototype.map === 'function') {\n            return array.map(fn, thisArg);\n        } else {\n            var output = new Array(array.length);\n            for (var i = 0; i < array.length; i++) {\n                output[i] = fn.call(thisArg, array[i]);\n            }\n            return output;\n        }\n    }\n\n    function _filter(array, fn, thisArg) {\n        if (typeof Array.prototype.filter === 'function') {\n            return array.filter(fn, thisArg);\n        } else {\n            var output = [];\n            for (var i = 0; i < array.length; i++) {\n                if (fn.call(thisArg, array[i])) {\n                    output.push(array[i]);\n                }\n            }\n            return output;\n        }\n    }\n\n    function _indexOf(array, target) {\n        if (typeof Array.prototype.indexOf === 'function') {\n            return array.indexOf(target);\n        } else {\n            for (var i = 0; i < array.length; i++) {\n                if (array[i] === target) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return _map(filtered, function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n"]}